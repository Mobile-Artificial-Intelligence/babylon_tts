// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// babylon.cpp binding
class babylon {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  babylon(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  babylon.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int babylon_g2p_init(
    ffi.Pointer<ffi.Char> model_path,
    babylon_g2p_options_t options,
  ) {
    return _babylon_g2p_init(
      model_path,
      options,
    );
  }

  late final _babylon_g2p_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              babylon_g2p_options_t)>>('babylon_g2p_init');
  late final _babylon_g2p_init = _babylon_g2p_initPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, babylon_g2p_options_t)>();

  ffi.Pointer<ffi.Char> babylon_g2p(
    ffi.Pointer<ffi.Char> text,
  ) {
    return _babylon_g2p(
      text,
    );
  }

  late final _babylon_g2pPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('babylon_g2p');
  late final _babylon_g2p = _babylon_g2pPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Int> babylon_g2p_tokens(
    ffi.Pointer<ffi.Char> text,
  ) {
    return _babylon_g2p_tokens(
      text,
    );
  }

  late final _babylon_g2p_tokensPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int> Function(
              ffi.Pointer<ffi.Char>)>>('babylon_g2p_tokens');
  late final _babylon_g2p_tokens = _babylon_g2p_tokensPtr
      .asFunction<ffi.Pointer<ffi.Int> Function(ffi.Pointer<ffi.Char>)>();

  void babylon_g2p_free() {
    return _babylon_g2p_free();
  }

  late final _babylon_g2p_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('babylon_g2p_free');
  late final _babylon_g2p_free =
      _babylon_g2p_freePtr.asFunction<void Function()>();

  int babylon_tts_init(
    ffi.Pointer<ffi.Char> model_path,
  ) {
    return _babylon_tts_init(
      model_path,
    );
  }

  late final _babylon_tts_initPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'babylon_tts_init');
  late final _babylon_tts_init =
      _babylon_tts_initPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  void babylon_tts(
    ffi.Pointer<ffi.Char> text,
    ffi.Pointer<ffi.Char> output_path,
  ) {
    return _babylon_tts(
      text,
      output_path,
    );
  }

  late final _babylon_ttsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('babylon_tts');
  late final _babylon_tts = _babylon_ttsPtr.asFunction<
      void Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  void babylon_tts_free() {
    return _babylon_tts_free();
  }

  late final _babylon_tts_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('babylon_tts_free');
  late final _babylon_tts_free =
      _babylon_tts_freePtr.asFunction<void Function()>();
}

final class babylon_g2p_options_t extends ffi.Struct {
  external ffi.Pointer<ffi.Char> language;

  @ffi.UnsignedChar()
  external int use_dictionaries;

  @ffi.UnsignedChar()
  external int use_punctuation;
}
